`timescale 1ns / 1ps

import common::*;
import ref_model_pkg::*;

module decode_execute_props(
    input  logic            clk,
    input  logic            reset_n,

    // --- from decode_execute_top ports / internal signals (bound by bind file) ---
    input  instruction_type instruction,
    input  logic [31:0]     pc_in,

    // decode-stage internal taps
    input  logic [4:0]      reg_rd_id,
    input  logic [31:0]     read_data1,
    input  logic [31:0]     read_data2,
    input  logic [31:0]     immediate_data,
    input  logic [31:0]     decode_pc_out,
    input  control_type     control_signals,
    input  control_type     control_signals_sanitized,
    input  logic            instruction_illegal,
    input  logic [31:0]     wb_forward_data,
    input  logic [31:0]     mem_forward_data,
    input  forward_type     forward_rs1,
    input  forward_type     forward_rs2,

    // execute-stage outputs
    input  control_type     control_out,
    input  logic [31:0]     alu_data,
    input  logic [31:0]     memory_data,
    input  logic            pc_src,
    input  logic [31:0]     jalr_target_offset,
    input  logic            jalr_flag,
    input  logic [31:0]     pc_out,
    input  logic            overflow
);

    // -----------------------------
    // Reference model signals
    // -----------------------------
    control_type ref_control;
    logic        ref_decode_failed;
    logic        ref_reg_illegal_flag;
    logic        ref_instruction_illegal;
    control_type ref_control_sanitized;

    logic [31:0] data2_or_imm;
    logic [31:0] left_operand;
    logic [31:0] right_operand;
    logic [31:0] rs2_forwarded;
    logic [31:0] store_data;

    logic [31:0] ref_alu_result;
    logic        ref_zero_flag;

    logic [31:0] ref_alu_data;
    logic [31:0] ref_memory_data;
    logic        ref_pc_src;
    logic [31:0] ref_jalr_target_offset;
    logic        ref_jalr_flag;
    logic [31:0] ref_pc_out;
    logic        ref_overflow_flag;

    // -----------------------------
    // Combinational reference model
    // -----------------------------
    always_comb begin
        // Decode reference
        ref_decode(instruction, ref_control, ref_decode_failed);
        ref_reg_illegal_flag     = ref_reg_illegal(ref_control, instruction, reg_rd_id);
        ref_instruction_illegal  = ref_decode_failed | ref_reg_illegal_flag;
        ref_control_sanitized    = ref_instruction_illegal ? '0 : ref_control;

        // Execute reference with forwarding selection
        data2_or_imm   = (ref_control_sanitized.alu_src) ? immediate_data : read_data2;
        left_operand   = ref_forward_select(read_data1, wb_forward_data, mem_forward_data, forward_rs1);
        rs2_forwarded  = ref_forward_select(data2_or_imm, wb_forward_data, mem_forward_data, forward_rs2);

        case (ref_control_sanitized.encoding)
            R_TYPE, S_TYPE, B_TYPE: right_operand = rs2_forwarded;
            default: right_operand = data2_or_imm;
        endcase
        if (ref_control_sanitized.encoding == S_TYPE)
            right_operand = data2_or_imm;

        ref_alu_result = ref_alu(ref_control_sanitized.alu_op, left_operand, right_operand);
        ref_zero_flag  = (ref_alu_result == 32'd0);

        // Default
        ref_alu_data          = ref_alu_result;
        ref_jalr_flag         = 1'b0;
        ref_jalr_target_offset= '0;

        // JALR (I_TYPE + is_branch) / J_TYPE special case: writeback pc+4
        if (ref_control_sanitized.encoding == I_TYPE && ref_control_sanitized.is_branch) begin
            ref_alu_data           = decode_pc_out + 32'd4;
            ref_jalr_flag          = 1'b1;
            ref_jalr_target_offset = left_operand + immediate_data;
        end
        else if (ref_control_sanitized.encoding == J_TYPE) begin
            ref_alu_data           = decode_pc_out + 32'd4;
        end

        // Branch decision (your execute_stage: only B_TYPE uses zero_flag)
        if (ref_control_sanitized.encoding == B_TYPE)
            ref_pc_src = ref_zero_flag;
        else
            ref_pc_src = 1'b0;

        // Store data path with forwarding on rs2
        store_data = ref_forward_select(read_data2, wb_forward_data, mem_forward_data, forward_rs2);
        ref_memory_data   = (ref_control_sanitized.encoding == S_TYPE) ? store_data : read_data2;

        ref_pc_out        = decode_pc_out;

        // Overflow reference
        ref_overflow_flag = ref_overflow(ref_control_sanitized.alu_op,
                                         left_operand, right_operand, ref_alu_result);
    end

    // ============================================================
    // Assertions / Covers MUST be outside procedural blocks
    // ============================================================

    // (Optional cleaner style, keep explicit clk/rst form for clarity)
    assert_control_matches_ref: assert property (@(posedge clk) disable iff (!reset_n)
        control_signals == ref_control
    );

    // Illegal flag matches reference decode/regs check.
    assert_illegal_matches_ref: assert property (@(posedge clk) disable iff (!reset_n)
        instruction_illegal == ref_instruction_illegal
    );

    // Sanitized control is zeroed when illegal.
    assert_sanitized_control: assert property (@(posedge clk) disable iff (!reset_n)
        control_signals_sanitized == (instruction_illegal ? '0 : control_signals)
    );

    // Execute control_out equals sanitized control.
    assert_execute_control_out: assert property (@(posedge clk) disable iff (!reset_n)
        control_out == ref_control_sanitized
    );

    // ALU output matches reference.
    assert_execute_alu_data: assert property (@(posedge clk) disable iff (!reset_n)
        alu_data == ref_alu_data
    );

    // Memory data output matches reference.
    assert_execute_memory_data: assert property (@(posedge clk) disable iff (!reset_n)
        memory_data == ref_memory_data
    );

    // PC source decision matches reference.
    assert_execute_pc_src: assert property (@(posedge clk) disable iff (!reset_n)
        pc_src == ref_pc_src
    );

    // JALR flag matches reference.
    assert_execute_jalr_flag: assert property (@(posedge clk) disable iff (!reset_n)
        jalr_flag == ref_jalr_flag
    );

    // JALR target offset matches reference.
    assert_execute_jalr_target: assert property (@(posedge clk) disable iff (!reset_n)
        jalr_target_offset == ref_jalr_target_offset
    );

    // PC out passes through decode PC.
    assert_execute_pc_out: assert property (@(posedge clk) disable iff (!reset_n)
        pc_out == ref_pc_out
    );

    // Overflow flag matches reference.
    assert_execute_overflow: assert property (@(posedge clk) disable iff (!reset_n)
        overflow == ref_overflow_flag
    );

    // JALR target must be aligned to 2 bytes (LSB cleared).
    assert_jalr_target_aligned: assert property (@(posedge clk) disable iff (!reset_n)
        jalr_flag |-> (jalr_target_offset[0] == 1'b0)
    );
    // JALR target equals (rs1 + imm) with LSB cleared.
    assert_jalr_target_masked: assert property (@(posedge clk) disable iff (!reset_n)
        jalr_flag |-> (jalr_target_offset == ((left_operand + immediate_data) & 32'hffff_fffe))
    );

    // Branch compare semantics for signed/unsigned variants.
    assert_blt_signed_compare: assert property (@(posedge clk) disable iff (!reset_n)
        (ref_control_sanitized.encoding == B_TYPE && ref_control_sanitized.alu_op == B_BLT) |->
            (pc_src == ($signed(left_operand) < $signed(right_operand)))
    );
    // BGE uses signed comparison.
    assert_bge_signed_compare: assert property (@(posedge clk) disable iff (!reset_n)
        (ref_control_sanitized.encoding == B_TYPE && ref_control_sanitized.alu_op == B_BGE) |->
            (pc_src == ($signed(left_operand) >= $signed(right_operand)))
    );
    // BLTU uses unsigned comparison.
    assert_bltu_unsigned_compare: assert property (@(posedge clk) disable iff (!reset_n)
        (ref_control_sanitized.encoding == B_TYPE && ref_control_sanitized.alu_op == B_LTU) |->
            (pc_src == (left_operand < right_operand))
    );
    // BGEU uses unsigned comparison.
    assert_bgeu_unsigned_compare: assert property (@(posedge clk) disable iff (!reset_n)
        (ref_control_sanitized.encoding == B_TYPE && ref_control_sanitized.alu_op == B_GEU) |->
            (pc_src == (left_operand >= right_operand))
    );

    // Writing x0 is legal; result is always zero.
    assert_x0_write_legal: assert property (@(posedge clk) disable iff (!reset_n)
        ((ref_control.encoding == R_TYPE || ref_control.encoding == I_TYPE ||
          ref_control.encoding == U_TYPE || ref_control.encoding == J_TYPE) &&
         instruction.rd == 5'd0) |-> !instruction_illegal
    );

    // Reset clears register file read outputs.
    assert_reset_clears_reads: assert property (@(posedge clk)
        !reset_n |=> (read_data1 == 32'd0 && read_data2 == 32'd0)
    );

    assume_no_write_during_reset: assume property (@(posedge clk)
        !reset_n |-> !write_en
    );

    // Read outputs stay zero after reset without writes.
    assert_reset_holds_reads: assert property (@(posedge clk) disable iff (!reset_n)
        (!write_en && read_data1 == 32'd0 && read_data2 == 32'd0) |=> (read_data1 == 32'd0 && read_data2 == 32'd0)
    );

    assume_pc_aligned: assume property (@(posedge clk) disable iff (!reset_n)
        pc_in[1:0] == 2'b00
    );

    assume_instruction_stable: assume property (@(posedge clk) disable iff (!reset_n)
        $stable(instruction)
    );

    assume_supported_opcode: assume property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode inside {7'b0110011, 7'b0010011, 7'b0000011, 7'b1100111,
                                   7'b1101111, 7'b0100011, 7'b1100011, 7'b0110111,
                                   7'b0010111} ||
        instruction == 32'h00000000 || instruction == 32'h00001111 ||
        instruction.opcode == 7'b1111111
    );

    assume_shift_imm_funct7: assume property (@(posedge clk) disable iff (!reset_n)
        (instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b001) |->
            (instruction.funct7[6:1] == 6'b000000)
    );
    assume_shift_imm_funct7_alt: assume property (@(posedge clk) disable iff (!reset_n)
        (instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b101) |->
            (instruction.funct7[6:1] == 6'b000000 || instruction.funct7[6:1] == 6'b010000)
    );

    // Decode failure implies illegal instruction.
    assert_decode_failed_illegal: assert property (@(posedge clk) disable iff (!reset_n)
        ref_decode_failed |-> instruction_illegal
    );
    // Illegal register use implies illegal instruction.
    assert_reg_illegal_illegal: assert property (@(posedge clk) disable iff (!reset_n)
        ref_reg_illegal_flag |-> instruction_illegal
    );

    // RS1 forwarding from EX selects mem_forward_data.
    assert_forward_rs1_sel: assert property (@(posedge clk) disable iff (!reset_n)
        (forward_rs1 == FORWARD_FROM_EX)  |-> (left_operand == mem_forward_data)
    );
    // RS1 forwarding from MEM selects wb_forward_data.
    assert_forward_rs1_sel_mem: assert property (@(posedge clk) disable iff (!reset_n)
        (forward_rs1 == FORWARD_FROM_MEM) |-> (left_operand == wb_forward_data)
    );
    // RS1 forwarding NONE selects register data.
    assert_forward_rs1_sel_none: assert property (@(posedge clk) disable iff (!reset_n)
        (forward_rs1 == FORWARD_NONE)     |-> (left_operand == read_data1)
    );

    // RS2 forwarding from EX selects mem_forward_data.
    assert_forward_rs2_sel: assert property (@(posedge clk) disable iff (!reset_n)
        (forward_rs2 == FORWARD_FROM_EX)  |-> (rs2_forwarded == mem_forward_data)
    );
    // RS2 forwarding from MEM selects wb_forward_data.
    assert_forward_rs2_sel_mem: assert property (@(posedge clk) disable iff (!reset_n)
        (forward_rs2 == FORWARD_FROM_MEM) |-> (rs2_forwarded == wb_forward_data)
    );
    // RS2 forwarding NONE selects register/immediate.
    assert_forward_rs2_sel_none: assert property (@(posedge clk) disable iff (!reset_n)
        (forward_rs2 == FORWARD_NONE)     |-> (rs2_forwarded == data2_or_imm)
    );

    // Store data reflects RS2 forwarding.
    assert_store_data_forward: assert property (@(posedge clk) disable iff (!reset_n)
        (ref_control_sanitized.encoding == S_TYPE) |-> (memory_data == store_data)
    );

    // Covers for basic instruction-type reachability
    cover_r_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == R_TYPE
    );

    cover_i_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == I_TYPE
    );

    cover_s_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == S_TYPE
    );

    cover_b_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == B_TYPE
    );

    cover_u_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == U_TYPE
    );

    cover_j_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == J_TYPE
    );

    cover_reset_fall: cover property (@(posedge clk)
        $fell(reset_n)
    );
    cover_reset_rise: cover property (@(posedge clk)
        $rose(reset_n)
    );

    cover_reset_asserted: cover property (@(posedge clk)
        !reset_n
    );

    cover_illegal_decode: cover property (@(posedge clk) disable iff (!reset_n)
        ref_decode_failed
    );
    cover_illegal_reg: cover property (@(posedge clk) disable iff (!reset_n)
        ref_reg_illegal_flag
    );
    cover_illegal_any: cover property (@(posedge clk) disable iff (!reset_n)
        ref_instruction_illegal
    );

    cover_r_add: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b000 && instruction.funct7[5] == 1'b0
    );
    cover_r_sub: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b000 && instruction.funct7[5] == 1'b1
    );
    cover_r_sll: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b001
    );
    cover_r_slt: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b010
    );
    cover_r_sltu: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b011
    );
    cover_r_xor: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b100
    );
    cover_r_srl: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b101 && instruction.funct7[5] == 1'b0
    );
    cover_r_sra: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b101 && instruction.funct7[5] == 1'b1
    );
    cover_r_or: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b110
    );
    cover_r_and: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110011 && instruction.funct3 == 3'b111
    );

    cover_i_addi: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b000
    );
    cover_i_slli: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b001
    );
    cover_i_slti: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b010
    );
    cover_i_sltiu: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b011
    );
    cover_i_xori: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b100
    );
    cover_i_srli: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b101 && instruction.funct7[5] == 1'b0
    );
    cover_i_srai: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b101 && instruction.funct7[5] == 1'b1
    );
    cover_i_ori: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b110
    );
    cover_i_andi: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010011 && instruction.funct3 == 3'b111
    );

    cover_l_lb: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0000011 && instruction.funct3 == 3'b000
    );
    cover_l_lh: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0000011 && instruction.funct3 == 3'b001
    );
    cover_l_lw: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0000011 && instruction.funct3 == 3'b010
    );
    cover_l_lbu: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0000011 && instruction.funct3 == 3'b100
    );
    cover_l_lhu: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0000011 && instruction.funct3 == 3'b101
    );

    cover_s_sb: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0100011 && instruction.funct3 == 3'b000
    );
    cover_s_sh: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0100011 && instruction.funct3 == 3'b001
    );
    cover_s_sw: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0100011 && instruction.funct3 == 3'b010
    );

    cover_b_beq: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b1100011 && instruction.funct3 == 3'b000
    );
    cover_b_bne: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b1100011 && instruction.funct3 == 3'b001
    );
    cover_b_blt: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b1100011 && instruction.funct3 == 3'b100
    );
    cover_b_bge: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b1100011 && instruction.funct3 == 3'b101
    );
    cover_b_bltu: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b1100011 && instruction.funct3 == 3'b110
    );
    cover_b_bgeu: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b1100011 && instruction.funct3 == 3'b111
    );

    cover_jalr: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b1100111
    );
    cover_jal: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b1101111
    );
    cover_lui: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0110111
    );
    cover_auipc: cover property (@(posedge clk) disable iff (!reset_n)
        instruction.opcode == 7'b0010111
    );

    cover_forward_rs1_ex: cover property (@(posedge clk) disable iff (!reset_n)
        forward_rs1 == FORWARD_FROM_EX
    );
    cover_forward_rs1_mem: cover property (@(posedge clk) disable iff (!reset_n)
        forward_rs1 == FORWARD_FROM_MEM
    );
    cover_forward_rs1_none: cover property (@(posedge clk) disable iff (!reset_n)
        forward_rs1 == FORWARD_NONE
    );

    cover_forward_rs2_ex: cover property (@(posedge clk) disable iff (!reset_n)
        forward_rs2 == FORWARD_FROM_EX
    );
    cover_forward_rs2_mem: cover property (@(posedge clk) disable iff (!reset_n)
        forward_rs2 == FORWARD_FROM_MEM
    );
    cover_forward_rs2_none: cover property (@(posedge clk) disable iff (!reset_n)
        forward_rs2 == FORWARD_NONE
    );

endmodule

