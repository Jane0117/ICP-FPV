`timescale 1ns / 1ps

import common::*;

module decode_execute_sva(
    input logic clk,
    input logic reset_n,
    input instruction_type instruction,
    input logic [31:0] pc_in,
    input control_type control_signals,
    input control_type control_signals_sanitized,
    input logic [4:0] reg_rd_id,
    input logic [31:0] read_data1,
    input logic [31:0] read_data2,
    input logic [31:0] immediate_data,
    input logic [31:0] decode_pc_out,
    input logic instruction_illegal,
    input control_type control_out,
    input logic [31:0] alu_data,
    input logic [31:0] memory_data,
    input logic pc_src,
    input logic [31:0] jalr_target_offset,
    input logic jalr_flag,
    input logic [31:0] pc_out,
    input logic overflow
);

    control_type ref_control;
    control_type ref_control_sanitized;
    logic ref_decode_failed;
    logic ref_reg_illegal_flag;
    logic ref_instruction_illegal;

    logic [31:0] ref_alu_result;
    logic ref_zero_flag;
    logic [31:0] ref_alu_data;
    logic [31:0] ref_memory_data;
    logic ref_pc_src;
    logic [31:0] ref_jalr_target_offset;
    logic ref_jalr_flag;
    logic [31:0] ref_pc_out;
    logic ref_overflow;

    function automatic void ref_decode(instruction_type instr,
                                       output control_type control,
                                       output logic decode_failed);
        control = '0;
        decode_failed = 1'b0;
        unique case (instr.opcode)
            // R type
            7'b0110011: begin
                control.encoding  = R_TYPE;
                control.reg_write = 1'b1;
                unique casez({instr.funct7[5], instr.funct3})
                    4'b0_000: control.alu_op = ALU_ADD;
                    4'b1_000: control.alu_op = ALU_SUB;
                    4'b?_001: control.alu_op = ALU_SLL;
                    4'b?_010: control.alu_op = ALU_SLT;
                    4'b?_011: control.alu_op = ALU_SLTU;
                    4'b?_100: control.alu_op = ALU_XOR;
                    4'b0_101: control.alu_op = ALU_SRL;
                    4'b1_101: control.alu_op = ALU_SRA;
                    4'b?_110: control.alu_op = ALU_OR;
                    4'b?_111: control.alu_op = ALU_AND;
                    default: decode_failed = 1'b1;
                endcase
            end
            // I type ALU
            7'b0010011: begin
                control.encoding  = I_TYPE;
                control.reg_write = 1'b1;
                control.alu_src   = 1'b1;
                unique casez({instr.funct7[5], instr.funct3})
                    4'b?_000: control.alu_op = ALU_ADD;
                    4'b?_001: control.alu_op = ALU_SLL;
                    4'b?_010: control.alu_op = ALU_SLT;
                    4'b?_011: control.alu_op = ALU_SLTU;
                    4'b?_100: control.alu_op = ALU_XOR;
                    4'b0_101: control.alu_op = ALU_SRL;
                    4'b1_101: control.alu_op = ALU_SRA;
                    4'b?_110: control.alu_op = ALU_OR;
                    4'b?_111: control.alu_op = ALU_AND;
                    default: decode_failed = 1'b1;
                endcase
            end
            // Load
            7'b0000011: begin
                control.encoding   = I_TYPE;
                control.reg_write  = 1'b1;
                control.alu_src    = 1'b1;
                control.mem_read   = 1'b1;
                control.mem_to_reg = 1'b1;
                control.alu_op     = ALU_ADD;
                unique casez(instr.funct3)
                    3'b000: control.mem_size = 2'b00;
                    3'b001: control.mem_size = 2'b01;
                    3'b010: control.mem_size = 2'b10;
                    3'b100: control.mem_size = 2'b00;
                    3'b101: control.mem_size = 2'b01;
                    default: decode_failed = 1'b1;
                endcase
                unique casez(instr.funct3)
                    3'b0??: control.mem_sign = 1'b1;
                    3'b1??: control.mem_sign = 1'b0;
                    default: decode_failed = 1'b1;
                endcase
            end
            // JALR
            7'b1100111: begin
                control.encoding  = I_TYPE;
                control.is_branch = 1'b1;
                control.reg_write = 1'b1;
                control.alu_op    = ALU_ADD;
            end
            // JAL
            7'b1101111: begin
                control.encoding  = J_TYPE;
                control.is_branch = 1'b0;
                control.reg_write = 1'b1;
                control.alu_op    = ALU_ADD;
            end
            // Store
            7'b0100011: begin
                control.encoding = S_TYPE;
                control.alu_src  = 1'b1;
                control.mem_write= 1'b1;
                control.alu_op   = ALU_ADD;
                unique casez(instr.funct3)
                    3'b000: control.mem_size = 2'b00;
                    3'b001: control.mem_size = 2'b01;
                    3'b010: control.mem_size = 2'b10;
                    default: decode_failed = 1'b1;
                endcase
            end
            // Branch
            7'b1100011: begin
                control.encoding  = B_TYPE;
                control.is_branch = 1'b1;
                unique casez({instr.funct3, instr.opcode})
                    BEQ_INSTRUCTION:  control.alu_op = ALU_SUB;
                    BNE_INSTRUCTION:  control.alu_op = B_BNE;
                    BLT_INSTRUCTION:  control.alu_op = B_BLT;
                    BGE_INSTRUCTION:  control.alu_op = B_BGE;
                    BLTU_INSTRUCTION: control.alu_op = B_LTU;
                    BGEU_INSTRUCTION: control.alu_op = B_GEU;
                    default: decode_failed = 1'b1;
                endcase
            end
            // LUI
            7'b0110111: begin
                control.encoding  = U_TYPE;
                control.reg_write = 1'b1;
                control.alu_src   = 1'b1;
                control.alu_op    = ALU_LUI;
            end
            // AUIPC
            7'b0010111: begin
                control.encoding  = U_TYPE;
                control.reg_write = 1'b1;
                control.alu_op    = ALU_ADD;
            end
            default: begin
                if (instr == 32'h00001111 || instr == 32'h00000000)
                    control = '0;
                else
                    decode_failed = 1'b1;
            end
        endcase
    endfunction

    function automatic logic ref_reg_illegal(control_type control,
                                              instruction_type instr,
                                              logic [4:0] rd_id);
        logic reg_illegal;
        reg_illegal = 1'b0;
        if (((control.encoding == R_TYPE||control.encoding == I_TYPE||control.encoding == U_TYPE||control.encoding == J_TYPE)
             && rd_id == 0) || rd_id >= REGISTER_FILE_SIZE) begin
            if (instr.opcode != 7'b1100111 && instr != 32'h00000013)
                reg_illegal = 1'b1;
        end
        if ((control.encoding == R_TYPE||control.encoding == I_TYPE||control.encoding == S_TYPE
             ||control.encoding == B_TYPE) && instr.rs1 >= REGISTER_FILE_SIZE) begin
            reg_illegal = 1'b1;
        end
        if ((control.encoding == R_TYPE||control.encoding == S_TYPE||control.encoding == B_TYPE)
             && instr.rs2 >= REGISTER_FILE_SIZE) begin
            reg_illegal = 1'b1;
        end
        return reg_illegal;
    endfunction

    always_comb begin
        logic [31:0] data2_or_imm;
        logic [31:0] left_operand;
        logic [31:0] right_operand;

        ref_decode(instruction, ref_control, ref_decode_failed);
        ref_reg_illegal_flag = ref_reg_illegal(ref_control, instruction, reg_rd_id);
        ref_instruction_illegal = ref_decode_failed | ref_reg_illegal_flag;
        ref_control_sanitized = ref_instruction_illegal ? '0 : ref_control;

        data2_or_imm = (ref_control_sanitized.alu_src) ? immediate_data : read_data2;
        left_operand = read_data1;
        case (ref_control_sanitized.encoding)
            S_TYPE: right_operand = immediate_data;
            R_TYPE, B_TYPE: right_operand = read_data2;
            default: right_operand = data2_or_imm;
        endcase

        unique case (ref_control_sanitized.alu_op)
            ALU_ADD:  ref_alu_result = left_operand + right_operand;
            ALU_SUB:  ref_alu_result = left_operand - right_operand;
            ALU_SLL:  ref_alu_result = left_operand << right_operand[4:0];
            ALU_SRL:  ref_alu_result = left_operand >> right_operand[4:0];
            ALU_SRA:  ref_alu_result = $signed(left_operand) >>> right_operand[4:0];
            ALU_SLT:  ref_alu_result = ($signed(left_operand) < $signed(right_operand)) ? 32'd1 : 32'd0;
            ALU_SLTU: ref_alu_result = (left_operand < right_operand) ? 32'd1 : 32'd0;
            ALU_XOR:  ref_alu_result = left_operand ^ right_operand;
            ALU_OR:   ref_alu_result = left_operand | right_operand;
            ALU_AND:  ref_alu_result = left_operand & right_operand;
            ALU_LUI:  ref_alu_result = immediate_data;
            B_BNE:    ref_alu_result = !(left_operand != right_operand);
            B_BLT:    ref_alu_result = !($signed(left_operand) < $signed(right_operand));
            B_BGE:    ref_alu_result = !($signed(left_operand) >= $signed(right_operand));
            B_LTU:    ref_alu_result = !(left_operand < right_operand);
            B_GEU:    ref_alu_result = !(left_operand >= right_operand);
            default:  ref_alu_result = left_operand + right_operand;
        endcase
        ref_zero_flag = (ref_alu_result == 0);

        ref_alu_data = ref_alu_result;
        ref_jalr_flag = 1'b0;
        ref_jalr_target_offset = '0;
        if (ref_control_sanitized.encoding == I_TYPE && ref_control_sanitized.is_branch) begin
            ref_alu_data = decode_pc_out + 32'd4;
            ref_jalr_flag = 1'b1;
            ref_jalr_target_offset = left_operand + immediate_data;
        end else if (ref_control_sanitized.encoding == J_TYPE) begin
            ref_alu_data = decode_pc_out + 32'd4;
        end

        if (ref_control_sanitized.encoding == B_TYPE)
            ref_pc_src = ref_zero_flag;
        else
            ref_pc_src = 1'b0;

        ref_memory_data = read_data2;
        ref_pc_out = decode_pc_out;

        if (ref_control_sanitized.alu_op == ALU_ADD) begin
            ref_overflow = (~(left_operand[31] ^ right_operand[31])) &
                           (left_operand[31] ^ ref_alu_result[31]);
        end else if (ref_control_sanitized.alu_op == ALU_SUB) begin
            ref_overflow = (left_operand[31] ^ right_operand[31]) &
                           (left_operand[31] ^ ref_alu_result[31]);
        end else begin
            ref_overflow = 1'b0;
        end
    end

    assert_control_matches_ref: assert property (@(posedge clk) disable iff (!reset_n)
        control_signals == ref_control
    );

    assert_instruction_illegal_matches_ref: assert property (@(posedge clk) disable iff (!reset_n)
        instruction_illegal == ref_instruction_illegal
    );

    assert_sanitized_control: assert property (@(posedge clk) disable iff (!reset_n)
        control_signals_sanitized == (instruction_illegal ? '0 : control_signals)
    );

    assert_execute_control_out: assert property (@(posedge clk) disable iff (!reset_n)
        control_out == control_signals_sanitized
    );

    assert_execute_alu_data: assert property (@(posedge clk) disable iff (!reset_n)
        alu_data == ref_alu_data
    );

    assert_execute_memory_data: assert property (@(posedge clk) disable iff (!reset_n)
        memory_data == ref_memory_data
    );

    assert_execute_pc_src: assert property (@(posedge clk) disable iff (!reset_n)
        pc_src == ref_pc_src
    );

    assert_execute_jalr_flag: assert property (@(posedge clk) disable iff (!reset_n)
        jalr_flag == ref_jalr_flag
    );

    assert_execute_jalr_target: assert property (@(posedge clk) disable iff (!reset_n)
        jalr_target_offset == ref_jalr_target_offset
    );

    assert_execute_pc_out: assert property (@(posedge clk) disable iff (!reset_n)
        pc_out == ref_pc_out
    );

    assert_execute_overflow: assert property (@(posedge clk) disable iff (!reset_n)
        overflow == ref_overflow
    );

    cover_r_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == R_TYPE
    );
    cover_i_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == I_TYPE
    );
    cover_s_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == S_TYPE
    );
    cover_b_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == B_TYPE
    );
    cover_u_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == U_TYPE
    );
    cover_j_type: cover property (@(posedge clk) disable iff (!reset_n)
        ref_control_sanitized.encoding == J_TYPE
    );

endmodule
